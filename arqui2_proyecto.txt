; CPURUM
; Author: Jerico Cancel(11000048325), Owen Colon(11000047933)
; March 23, 2021

#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        
        ORG     01C00h                  ; To count how many times button S1 
;ram        db 0x16, 0x27, 0x27, 0x27, 0x38, 0xF5, 0xAB, 0x3E, 0x00              ;Prueba #1
;ram        db 0x07, 0x18, 0x18, 0x48, 0x38, 0x38, 0xF6, 0xC3, 0x56              ;Prueba #2
;ram        db 0x18, 0x29, 0xA4, 0xC1, 0x3A, 0x3A, 0x3A, 0xF6, 0xC3, 0x56, 0x00  ;Prueba #3
;ram        db 0x17, 0xC5, 0x38, 0x38, 0x38, 0x38, 0xF6, 0xF1, 0x00              ;Prueba #4
ram        db 0x17, 0xE6, 0xCE, 0xE8, 0xE6, 0x38, 0xF6, 0x81, 0x00              ;Prueba #5           
runningInDebugger db 1

displayPos db 0x09,0x05,0x03,0x12,0x0E,0x07
cpurumH	   db 0x9C,0xCF,0x7C,0xCF,0x7C,0x6C
cpurumL	   db 0x00,0x00,0x00,0x02,0x00,0xA0

S2togoH	   db 0xB7,0xDB,0x80,0xFC,0xBD,0xFC
S2togoL	   db 0x00,0x00,0x50,0x00,0x00,0x00

integrantesH db 0xF0,0x9F,0xCF,0x90,0x9C,0xFC,  0xFC,0x6C,0x9F,0x6C,0x00,0x00 
integrantesL db 0x00,0x00,0x02,0x50,0x00,0x00,  0x00,0x0A,0x00,0x82,0x00,0x00
        
        
        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
                                                       
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

;Has some design errors like not initializing pushCount to 0 in the code.
;The program don't clear the push button interrupt flag at the beginning
;leaving the possibility of a false interrupt due to a previous push
;(this is solved uncommenting the two lines of codes)

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        ;bic.b   #0xFF,&P9SEL0
        ;bic.b   #0xFF,&P9SEL1

        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        ;bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        ;bic.b   #00000001b, &P1OUT      ; Turn off red and green LEDs
        ;bic.b   #10000000b, &P9OUT

        bis.b   #06h, &P1REN            ; P1.2 Resistor enabled as pullup
        bis.b   #04h, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #04h, &P1IE             ; Enable interrupt at P1.2
        bis.b   #04h, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.2

        ;datast
				;Initialize LCD segments 0 - 21; 26 - 43
	MOV.W   #0xFFFF,&LCDCPCTL0
	MOV.W   #0xfc3f,&LCDCPCTL1
    	MOV.W   #0x0fff,&LCDCPCTL2

        
        ;Initialize LCD_C
    	;ACLK, Divider = 1, Pre-divider = 16; 4-pin MUX
	MOV.W   #0x041e,&LCDCCTL0
        
        ;VLCD generated internally,
    	;V2-V4 generated internally, v5 to ground
    	;Set VLCD voltage to 2.60v
    	;Enable charge pump and select internal reference for it
    	MOV.W   #0x0208,&LCDCVCTL

        MOV.W   #0x8000,&LCDCCPCTL   ;Clock synchronization enabled

        MOV.W   #2,&LCDCMEMCTL       ;Clear LCD memory

        ;Turn LCD on
        BIS.W   #1,&LCDCCTL0
        MOV.B	#0,R6
        MOV.B	#0,R7
        MOV.B   #0,R9
        
        


UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings

        ;mov     #0, pushCount         ; When using reset with the debugger
                                        ; the memory content is not reset to
                                        ; original values. To take care of
                                        ; that situation pushCount is reset
                                        ; to 0
  
        bic.b   #00000100b, &P1IFG    ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

;        bis     #LPM0,SR                ; Enter Low Power Mode 0
        NOP



;Objetivo: Presentar 'CPURUM' usando un loop que itera un arreglo de posiciones de disolay y otro arreglo que corresponde a los caracteres
;Precondiciones: R6 debe ser 0. 
;Postcondiciones: El display ahora dice CPURUM
;Autor: Owen Colon 
;Fecha: 23/abr/2023
        
cpurumLoop:
            MOV.B   displayPos(R6),R14
            MOV.B   cpurumH(R6),0x0a20(R14)
            MOV.B   cpurumL(R6),0x0a20+1(R14)
            inc		R6
            cmp		#6,R6
            jnz		cpurumLoop
            MOV.B       #0,R6
            MOV.B       #0,R8
            
          
          
        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)






;Interrupt Service Routine (ISR) that will be executed when the push button S2
;is pressed.

PORT1_ISR
        bit.b   #00000100b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.2
                                        ; that corresponds to push button S2
                                        
        
        jz      S2TOGO_LOOP                     ; if no interrupt from push button
        
        bic.b   #00000010b, &P1IFG      ; Clear interrupt flag and check
        bic.b   #00000100b, &P1IFG 
        
        
        bis.b   #06h, &P1REN            ; P1.2 Resistor enabled as pullup
        bis.b   #06h, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #06h, &P1IE             ; Enable interrupt at P1.1
        bis.b   #06h, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1
        
        cmp     #1,R8
        jge     emulator
        


;Objetivo: Despues de la interrupcion se despliega el nombre de un integrante y al presionar el boton denuevo se despliega el proximo
;Precondiciones: R6 debe ser 0
;Postcondiciones: El display ensena el nombre de un integrante
;Autor: Owen Colon
;Fecha: 23/abr/2023



integrantesLoop:
                
                MOV.B   displayPos(R6),R14
                MOV.B   integrantesH(R7),0x0a20(R14)
	    	MOV.B   integrantesL(R7),0x0a20+1(R14)
	    	inc	R6
	    	inc	R7
	    	cmp	#6,R6
	    	jnz	integrantesLoop
                
                MOV.B   #0,R6
		cmp 	#12,R7
		jeq	resr7
        	jmp     fin

;Objetivo: Despues de la interrupcion por el boton S1 se despliega S2TOGO
;Precondiciones: R6 debe ser 0 y la interrupcion debe ser por P1.1
;Postcondiciones: El display ensena S2TOGO
;Autor: Jerico Cancel
;Fecha: 23/abr/2023


S2TOGO_LOOP:    MOV.B   displayPos(R6),R14
                MOV.B   S2togoH(R6),0x0a20(R14)
                MOV.B   S2togoL(R6),0x0a20+1(R14)
                inc	R6
                cmp	#6,R6
                jnz	S2TOGO_LOOP
                MOV.B   #0,R6
                MOV.B   #1,R8
                
                bic.b   #00000010b, &P1IFG      ; Clear interrupt flag and check
                bic.b   #00000100b, &P1IFG
        	jmp     fin

emulator: call #emulator_begin

        
fin:    ;inc     pushCount               ; Increment the pushes counter

        reti                            ; Return from interrupt

resr7:
	MOV.B	#0,R7
	jmp	fin
        
        
        
;Objetivo: Emular el cpurum 
;Precondiciones: Debe ocurrir una interrupcion despues de que S2TOGO este presente en el display 
;Postcondiciones: EMulacion comienza
;Autor: Jerico Cancel
;Fecha: 23/abr/2023       
        
        
        
        
emulator_begin: MOV.B    #0,R4                 ;PC

;Objetivo: Borra los caracteres del display para prepararlo para la emulacion
;Precondiciones: R6 debe ser 0
;Postcondiciones: El display ensena nada
;Autor: Jerico Cancel
;Fecha: 23/abr/2023



clearing_display:
                MOV.B   displayPos(R6),R14
                MOV.B   #0,0x0a20(R14)
                MOV.B   #0,0x0a20+1(R14)
                inc	R6
                cmp	#6,R6
                jnz	clearing_display
                MOV.B   #0,R6



;Objetivo: Borrar el contenido de los registros para la emulacion
;Precondiciones: ninguna
;Postcondiciones: Todos los registros tienen 0
;Autor: Jerico Cancel
;Fecha: 23/abr/2023
clearing_registers:
                MOV.B    #0,R4                 ;PC
                MOV.B    #0,R5                 ;stores opcode  RC
                MOV.B    #0,R6                 ;Rx
                MOV.B    #0,R7                 ;Ry
                MOV.B    #0,R8                 ;Rz
                MOV.B    #0,R9
                MOV.B    #0,R10                   ;R0
                MOV.B    #0,R11                ;R1
                MOV.B    #0,R12                ;R2
                MOV.B    #0,R13                ;R3
                MOV.B    #0,R14
                MOV.B    #0,R15
                
                
                
;Objetivo: Llama el fetcher y decoder y hace loop a traves del PC del cpurum
;Precondiciones: ninguna
;Postcondiciones: la instruccion se ejecuta y el PC incrementa 1
;Autor: Jerico Cancel
;Fecha: 23/abr/2023                
empiezo:        call #Fetcher
                call #Decoder_Executer
                ;inc R4
                cmp  #16,R4
                jne  empiezo
                MOV.B #0,R4
                jmp empiezo
                ret

;Objetivo: Busca en el ram la instrucion que apunta el PC
;Precondiciones:ninguna
;Postcondiciones: R5 contiene la instruccion
;Autor: Jerico Cancel
;Fecha: 23/abr/2023   
Fetcher:    MOV.B   ram(R4),R5
            ret


;Objetivo: Recibe la instruccion R5 y decifra que registros y memoria estan involucrados y despues ejecuta la instruccion
;;Precondiciones: R5 debe tener la instruccion 
;Postcondiciones: Se encontro que instruccion se corre
;Autor: Jerico Cancel
;Fecha: 23/abr/2023              
Decoder_Executer:    MOV.B   R5,R6
            cmp     #240,R6
            jge     JR30_Decode
            
            MOV.B   R5,R6
            cmp     #224,R6
            jge     Out_Decode
            
            MOV.B   R5,R6
            cmp     #204,R6
            jge     In_Decode
            
            MOV.B   R5,R6
            cmp     #196,R6
            jge     Shr_Decode
            
            MOV.B   R5,R6
            cmp     #192,R6
            jge     Neg_Decode
            
            MOV.B   R5,R6
            cmp     #128,R6
            jge     Add_Decode
            
            MOV.B   R5,R6
            cmp     #64,R6
            jge     Store_Decode
            
            jmp     Load_Decode
            
fin_D: 
       ret


;Objetivo: Extrae de la instrccion los registros y memoria involucrados para la ejecucion
;;Precondiciones: R5 debe tener la instruccion 
;Postcondiciones: EN R7 se encuentra el registro y en R8 los contenidos de la memoria
;Autor: Jerico Cancel
;Fecha: 23/abr/2023

Load_Decode:
          MOV.B   R5,R6
          RRC.B   R6
          RRC.B   R6
          RRC.B   R6
          RRC.B   R6
          bic.b   #0xF0,R6
          MOV.B   R6,R7
          MOV.B   R5,R6
          bic.b   #11110000b,R6
          MOV.B   ram(R6),R8
          call #Load_execute
          jmp   fin_D
          


;Objetivo: Ejecuta la instruccion en el registro adecuado
;;Precondiciones: R7 debe tener el numero del registro 
;Postcondiciones: la instruccion se ejecuta en el registro
;Autor: Jerico Cancel
;Fecha: 23/abr/2023
Load_execute:
            cmp #0,R7
            jeq fin_D
            
            cmp #1,R7
            jeq load_R1
            
            cmp #2,R7
            jeq load_R2
            
            cmp #3,R7
            jeq load_R3
fin_exc: inc R4   
         ret            
            
load_R1:
        MOV.B   R8,R11
        jmp   fin_exc
        
load_R2:
        MOV.B   R8,R12
        jmp   fin_exc
        
load_R3:
        MOV.B   R8,R13
        jmp   fin_exc
        
;Objetivo: Extrae de la instrccion los registros y memoria involucrados para la ejecucion
;;Precondiciones: R5 debe tener la instruccion 
;Postcondiciones: EN R7 se encuentra el registro y en R8 los contenidos de la memoria
;Autor: Jerico Cancel
;Fecha: 23/abr/2023        
Store_Decode:
          MOV.B   R5,R6
          bic.b   #11000000b,R6
          RRC.B   R6
          RRC.B   R6
          RRC.B   R6
          RRC.B   R6
          bic.b   #0xF0,R6
          MOV.B   R6,R7             ;register 
          MOV.B   R5,R6
          bic.b   #11110000b,R6
          MOV.B   R6,R8        ;memory
          call    #Store_execute
          jmp   fin_D


;Objetivo: Ejecuta la instruccion en el registro adecuado
;;Precondiciones: R7 debe tener el numero del registro 
;Postcondiciones: la instruccion se ejecuta en el registro
;Autor: Jerico Cancel
;Fecha: 23/abr/2023          
Store_execute:
            cmp #0,R7
            jeq fin_exc
            
            cmp #1,R7
            jeq store_R1
            
            cmp #2,R7
            jeq store_R2
            
            cmp #3,R7
            jeq store_R3          
store_R1:
        MOV.B   R11,ram(R8)
        jmp   fin_D
        
store_R2:
        MOV.B   R12,ram(R8)
        jmp   fin_exc
        
store_R3:
        MOV.B   R13,ram(R8)
        jmp   fin_exc  
        
        
Neg_Decode: MOV.B    R5,R6
            bic.b    #11111100b,R6
            MOV.B    R6,R7
            call     #Neg_Execute
            ret
            
Neg_Execute:cmp #0,R7
            jeq fin_exc
            
            cmp #1,R7
            jeq Neg_R1
            
            cmp #2,R7
            jeq Neg_R2
            
            cmp #3,R7
            jeq Neg_R3
            
            
Neg_R1:
        XOR.B #0xFF,R11
        inc R11
        jmp   fin_exc
        
Neg_R2:
        XOR.B #0xFF,R12
        inc R12
        jmp   fin_exc
        
Neg_R3:
        XOR.B #0xFF,R13
        inc R13
        jmp   fin_exc
        
        
Shr_Decode:MOV.B R5,R6
           bic.b #11111100b,R6
           MOV.B R6,R7
           call  #Shr_Execute
           ret
           
           
Shr_Execute:cmp #0,R7
            jeq fin_exc
            
            cmp #1,R7
            jeq Shr_R1
            
            cmp #2,R7
            jeq Shr_R2
            
            cmp #3,R7
            jeq Shr_R3
            
Shr_R1:
        RRA   R11
        jmp   fin_exc
        
Shr_R2:
        RRA   R12
        jmp   fin_exc
        
Shr_R3:
        RRA   R13
        jmp   fin_exc            
           


JR30_Decode: MOV.B R5,R6
             bic.b #0xF0,R6
             MOV.B R6,R7
             call #JR30_Execute
             ret
             
JR30_Execute: cmp #0,R13
              jeq jr30_op
              jmp fin_exc
              
jr30_op:      MOV.B R7,R4
              jmp fin_exc
              
Out_Decode: jmp fin_D
In_Decode:  jmp fin_D


Add_Decode: MOV.B   R5,R6
          
          RRC.B   R6
          RRC.B   R6
          bic.b   #11111100b,R6
          MOV.B   R6,R7            ;R[ss]
          
          MOV.B   R5,R6
          
          RRC.B   R6
          RRC.B   R6
          RRC.B   R6
          RRC.B   R6
          
          bic.b   #11111100b,R6
          MOV.B   R6,R8            ;R[dd]
                       
          call    #Add_execute
          jmp   fin_D
          
Add_execute:
          cmp #0, R8
          jeq  fin_exc
          cmp #1,R8
          jeq  R1plusX
          cmp #2,R8
          jeq  R2plusX
          cmp #3,R8
          jeq  R3plusX
          
          jmp fin_D


R1plusX:
        cmp #0,R7
        jeq  R0plusR1
        
        cmp #1,R7
        jeq  R1plusR1
        
        cmp  #2,R7
        jeq  R2plusR1
        
        cmp  #3,R7
        jeq  R3plusR1
        
        

R0plusR1: ADD.B R10,R11
          jmp fin_exc
          
R1plusR1: ADD.B R11,R11
          jmp fin_exc
          
R2plusR1: ADD.B R12,R11
          jmp fin_exc 
          
R3plusR1: ADD.B R13,R11
          jmp fin_exc
          
          
R2plusX:  cmp #0,R7
        jeq  R0plusR2
        
        cmp #1,R7
        jeq  R1plusR2
        
        cmp  #2,R7
        jeq  R2plusR2
        
        cmp  #3,R7
        jeq  R3plusR2     
        
R0plusR2: ADD.B R10,R12
          jmp fin_exc
          
R1plusR2: ADD.B R11,R12
          jmp fin_exc
          
R2plusR2: ADD.B R12,R12
          jmp fin_exc 
          
R3plusR2: ADD.B R13,R12
          jmp fin_exc        
        
        
        
R3plusX: cmp #0,R7
        jeq  R0plusR3
        
        cmp #1,R7
        jeq  R1plusR3
        
        cmp  #2,R7
        jeq  R2plusR3
        
        cmp  #3,R7
        jeq  R3plusR3  
        
        
R0plusR3: ADD.B R10,R13
          jmp fin_exc
          
R1plusR3: ADD.B R11,R13
          jmp fin_exc
          
R2plusR3: ADD.B R12,R13
          jmp fin_exc 
          
R3plusR3: ADD.B R13,R13
          jmp fin_exc        
        
            
          
        END
